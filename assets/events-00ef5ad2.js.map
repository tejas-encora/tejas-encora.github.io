{"version":3,"file":"events-00ef5ad2.js","sources":["../../node_modules/@material/web/internal/controller/events.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Re-dispatches an event from the provided element.\n *\n * This function is useful for forwarding non-composed events, such as `change`\n * events.\n *\n * @example\n * class MyInput extends LitElement {\n *   render() {\n *     return html`<input @change=${this.redispatchEvent}>`;\n *   }\n *\n *   protected redispatchEvent(event: Event) {\n *     redispatchEvent(this, event);\n *   }\n * }\n *\n * @param element The element to dispatch the event from.\n * @param event The event to re-dispatch.\n * @return Whether or not the event was dispatched (if cancelable).\n */\nexport function redispatchEvent(element, event) {\n    // For bubbling events in SSR light DOM (or composed), stop their propagation\n    // and dispatch the copy.\n    if (event.bubbles && (!element.shadowRoot || event.composed)) {\n        event.stopPropagation();\n    }\n    const copy = Reflect.construct(event.constructor, [event.type, event]);\n    const dispatched = element.dispatchEvent(copy);\n    if (!dispatched) {\n        event.preventDefault();\n    }\n    return dispatched;\n}\n/**\n * Dispatches a click event to the given element that triggers a native action,\n * but is not composed and therefore is not seen outside the element.\n *\n * This is useful for responding to an external click event on the host element\n * that should trigger an internal action like a button click.\n *\n * Note, a helper is provided because setting this up correctly is a bit tricky.\n * In particular, calling `click` on an element creates a composed event, which\n * is not desirable, and a manually dispatched event must specifically be a\n * `MouseEvent` to trigger a native action.\n *\n * @example\n * hostClickListener = (event: MouseEvent) {\n *   if (isActivationClick(event)) {\n *     this.dispatchActivationClick(this.buttonElement);\n *   }\n * }\n *\n */\nexport function dispatchActivationClick(element) {\n    const event = new MouseEvent('click', { bubbles: true });\n    element.dispatchEvent(event);\n    return event;\n}\n/**\n * Returns true if the click event should trigger an activation behavior. The\n * behavior is defined by the element and is whatever it should do when\n * clicked.\n *\n * Typically when an element needs to handle a click, the click is generated\n * from within the element and an event listener within the element implements\n * the needed behavior; however, it's possible to fire a click directly\n * at the element that the element should handle. This method helps\n * distinguish these \"external\" clicks.\n *\n * An \"external\" click can be triggered in a number of ways: via a click\n * on an associated label for a form  associated element, calling\n * `element.click()`, or calling\n * `element.dispatchEvent(new MouseEvent('click', ...))`.\n *\n * Also works around Firefox issue\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1804576 by squelching\n * events for a microtask after called.\n *\n * @example\n * hostClickListener = (event: MouseEvent) {\n *   if (isActivationClick(event)) {\n *     this.dispatchActivationClick(this.buttonElement);\n *   }\n * }\n *\n */\nexport function isActivationClick(event) {\n    // Event must start at the event target.\n    if (event.currentTarget !== event.target) {\n        return false;\n    }\n    // Event must not be retargeted from shadowRoot.\n    if (event.composedPath()[0] !== event.target) {\n        return false;\n    }\n    // Target must not be disabled; this should only occur for a synthetically\n    // dispatched click.\n    if (event.target.disabled) {\n        return false;\n    }\n    // This is an activation if the event should not be squelched.\n    return !squelchEvent(event);\n}\n// TODO(https://bugzilla.mozilla.org/show_bug.cgi?id=1804576)\n//  Remove when Firefox bug is addressed.\nfunction squelchEvent(event) {\n    const squelched = isSquelchingEvents;\n    if (squelched) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n    }\n    squelchEventsForMicrotask();\n    return squelched;\n}\n// Ignore events for one microtask only.\nlet isSquelchingEvents = false;\nasync function squelchEventsForMicrotask() {\n    isSquelchingEvents = true;\n    // Need to pause for just one microtask.\n    // tslint:disable-next-line\n    await null;\n    isSquelchingEvents = false;\n}\n//# sourceMappingURL=events.js.map"],"names":["redispatchEvent","element","event","copy","dispatched","dispatchActivationClick","isActivationClick","squelchEvent","squelched","isSquelchingEvents","squelchEventsForMicrotask"],"mappings":"AAAA;AAAA;AAAA;AAAA;AAAA,GA0BO,SAASA,EAAgBC,EAASC,EAAO,CAGxCA,EAAM,UAAY,CAACD,EAAQ,YAAcC,EAAM,WAC/CA,EAAM,gBAAe,EAEzB,MAAMC,EAAO,QAAQ,UAAUD,EAAM,YAAa,CAACA,EAAM,KAAMA,CAAK,CAAC,EAC/DE,EAAaH,EAAQ,cAAcE,CAAI,EAC7C,OAAKC,GACDF,EAAM,eAAc,EAEjBE,CACX,CAqBO,SAASC,EAAwBJ,EAAS,CAC7C,MAAMC,EAAQ,IAAI,WAAW,QAAS,CAAE,QAAS,EAAI,CAAE,EACvD,OAAAD,EAAQ,cAAcC,CAAK,EACpBA,CACX,CA6BO,SAASI,EAAkBJ,EAAO,CAWrC,OATIA,EAAM,gBAAkBA,EAAM,QAI9BA,EAAM,aAAc,EAAC,CAAC,IAAMA,EAAM,QAKlCA,EAAM,OAAO,SACN,GAGJ,CAACK,EAAaL,CAAK,CAC9B,CAGA,SAASK,EAAaL,EAAO,CACzB,MAAMM,EAAYC,EAClB,OAAID,IACAN,EAAM,eAAc,EACpBA,EAAM,yBAAwB,GAElCQ,IACOF,CACX,CAEA,IAAIC,EAAqB,GACzB,eAAeC,GAA4B,CACvCD,EAAqB,GAGrB,MAAM,KACNA,EAAqB,EACzB","x_google_ignoreList":[0]}