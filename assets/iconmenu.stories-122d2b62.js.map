{"version":3,"file":"iconmenu.stories-122d2b62.js","sources":["../../node_modules/@material/web/menu/internal/forced-colors-styles.css.js","../../node_modules/@material/web/list/internal/list-navigation-helpers.js","../../node_modules/@material/web/list/internal/list-controller.js","../../node_modules/@material/web/menu/internal/controllers/shared.js","../../node_modules/@material/web/menu/internal/controllers/surfacePositionController.js","../../node_modules/@material/web/menu/internal/controllers/typeaheadController.js","../../node_modules/@material/web/menu/internal/menu.js","../../node_modules/@material/web/menu/internal/menu-styles.css.js","../../node_modules/@material/web/menu/menu.js","../../src/labs/Menu/IOIconMenu.vue"],"sourcesContent":["/**\n  * @license\n  * Copyright 2022 Google LLC\n  * SPDX-License-Identifier: Apache-2.0\n  */\nimport { css } from 'lit';\nexport const styles = css `@media(forced-colors: active){.menu{border-style:solid;border-color:CanvasText;border-width:1px}}/*# sourceMappingURL=forced-colors-styles.css.map */\n`;\n//# sourceMappingURL=forced-colors-styles.css.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Activates the first non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items from which to activate the\n *     first item.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n */\nexport function activateFirstItem(items, isActivatable = (isItemNotDisabled)) {\n    // NOTE: These selector functions are static and not on the instance such\n    // that multiple operations can be chained and we do not have to re-query\n    // the DOM\n    const firstItem = getFirstActivatableItem(items, isActivatable);\n    if (firstItem) {\n        firstItem.tabIndex = 0;\n        firstItem.focus();\n    }\n    return firstItem;\n}\n/**\n * Activates the last non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items from which to activate the\n *     last item.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @nocollapse\n */\nexport function activateLastItem(items, isActivatable = (isItemNotDisabled)) {\n    const lastItem = getLastActivatableItem(items, isActivatable);\n    if (lastItem) {\n        lastItem.tabIndex = 0;\n        lastItem.focus();\n    }\n    return lastItem;\n}\n/**\n * Deactivates the currently active item of a given array of items.\n *\n * @param items {Array<ListItem>} The items from which to deactivate the\n *     active item.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return A record of the deleselcted activated item including the item and\n *     the index of the item or `null` if none are deactivated.\n * @nocollapse\n */\nexport function deactivateActiveItem(items, isActivatable = (isItemNotDisabled)) {\n    const activeItem = getActiveItem(items, isActivatable);\n    if (activeItem) {\n        activeItem.item.tabIndex = -1;\n    }\n    return activeItem;\n}\n/**\n * Retrieves the first activated item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return A record of the first activated item including the item and the\n *     index of the item or `null` if none are activated.\n * @nocollapse\n */\nexport function getActiveItem(items, isActivatable = (isItemNotDisabled)) {\n    for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n        if (item.tabIndex === 0 && isActivatable(item)) {\n            return {\n                item,\n                index: i,\n            };\n        }\n    }\n    return null;\n}\n/**\n * Retrieves the first non-disabled item of a given array of items. This\n * the first item that is not disabled.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The first activatable item or `null` if none are activatable.\n * @nocollapse\n */\nexport function getFirstActivatableItem(items, isActivatable = (isItemNotDisabled)) {\n    for (const item of items) {\n        if (isActivatable(item)) {\n            return item;\n        }\n    }\n    return null;\n}\n/**\n * Retrieves the last non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The last activatable item or `null` if none are activatable.\n * @nocollapse\n */\nexport function getLastActivatableItem(items, isActivatable = (isItemNotDisabled)) {\n    for (let i = items.length - 1; i >= 0; i--) {\n        const item = items[i];\n        if (isActivatable(item)) {\n            return item;\n        }\n    }\n    return null;\n}\n/**\n * Retrieves the next non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param index {{index: number}} The index to search from.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The next activatable item or `null` if none are activatable.\n */\nexport function getNextItem(items, index, isActivatable = (isItemNotDisabled)) {\n    for (let i = 1; i < items.length; i++) {\n        const nextIndex = (i + index) % items.length;\n        const item = items[nextIndex];\n        if (isActivatable(item)) {\n            return item;\n        }\n    }\n    return items[index] ? items[index] : null;\n}\n/**\n * Retrieves the previous non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param index {{index: number}} The index to search from.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The previous activatable item or `null` if none are activatable.\n */\nexport function getPrevItem(items, index, isActivatable = (isItemNotDisabled)) {\n    for (let i = 1; i < items.length; i++) {\n        const prevIndex = (index - i + items.length) % items.length;\n        const item = items[prevIndex];\n        if (isActivatable(item)) {\n            return item;\n        }\n    }\n    return items[index] ? items[index] : null;\n}\n/**\n * Activates the next item and focuses it. If nothing is currently activated,\n * activates the first item.\n */\nexport function activateNextItem(items, activeItemRecord, isActivatable = (isItemNotDisabled)) {\n    if (activeItemRecord) {\n        const next = getNextItem(items, activeItemRecord.index, isActivatable);\n        if (next) {\n            next.tabIndex = 0;\n            next.focus();\n        }\n        return next;\n    }\n    else {\n        return activateFirstItem(items, isActivatable);\n    }\n}\n/**\n * Activates the previous item and focuses it. If nothing is currently\n * activated, activates the last item.\n */\nexport function activatePreviousItem(items, activeItemRecord, isActivatable = (isItemNotDisabled)) {\n    if (activeItemRecord) {\n        const prev = getPrevItem(items, activeItemRecord.index, isActivatable);\n        if (prev) {\n            prev.tabIndex = 0;\n            prev.focus();\n        }\n        return prev;\n    }\n    else {\n        return activateLastItem(items, isActivatable);\n    }\n}\n/**\n * Creates an event that requests the parent md-list to deactivate all other\n * items.\n */\nexport function createDeactivateItemsEvent() {\n    return new Event('deactivate-items', { bubbles: true, composed: true });\n}\n/**\n * Creates an event that requests the menu to set `tabindex=0` on the item and\n * focus it. We use this pattern because List keeps track of what element is\n * active in the List by maintaining tabindex. We do not want list items\n * to set tabindex on themselves or focus themselves so that we can organize all\n * that logic in the parent List and Menus, and list item stays as dumb as\n * possible.\n */\nexport function createRequestActivationEvent() {\n    return new Event('request-activation', { bubbles: true, composed: true });\n}\n/**\n * The default `isActivatable` function, which checks if an item is not\n * disabled.\n *\n * @param item The item to check.\n * @return true if `item.disabled` is `false.\n */\nfunction isItemNotDisabled(item) {\n    return !item.disabled;\n}\n//# sourceMappingURL=list-navigation-helpers.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { activateFirstItem, activateLastItem, activateNextItem, activatePreviousItem, getActiveItem, getFirstActivatableItem } from './list-navigation-helpers.js';\n// TODO: move this file to List and make List use this\n/**\n * Default keys that trigger navigation.\n */\n// tslint:disable:enforce-name-casing Following Enum style\nexport const NavigableKeys = {\n    ArrowDown: 'ArrowDown',\n    ArrowLeft: 'ArrowLeft',\n    ArrowUp: 'ArrowUp',\n    ArrowRight: 'ArrowRight',\n    Home: 'Home',\n    End: 'End',\n};\n/**\n * A controller that handles list keyboard navigation and item management.\n */\nexport class ListController {\n    constructor(config) {\n        /**\n         * Handles keyboard navigation. Should be bound to the node that will act as\n         * the List.\n         */\n        this.handleKeydown = (event) => {\n            const key = event.key;\n            if (event.defaultPrevented || !this.isNavigableKey(key)) {\n                return;\n            }\n            // do not use this.items directly in upcoming calculations so we don't\n            // re-query the DOM unnecessarily\n            const items = this.items;\n            if (!items.length) {\n                return;\n            }\n            const activeItemRecord = getActiveItem(items, this.isActivatable);\n            if (activeItemRecord) {\n                activeItemRecord.item.tabIndex = -1;\n            }\n            event.preventDefault();\n            const isRtl = this.isRtl();\n            const inlinePrevious = isRtl ? NavigableKeys.ArrowRight : NavigableKeys.ArrowLeft;\n            const inlineNext = isRtl ? NavigableKeys.ArrowLeft : NavigableKeys.ArrowRight;\n            switch (key) {\n                // Activate the next item\n                case NavigableKeys.ArrowDown:\n                case inlineNext:\n                    activateNextItem(items, activeItemRecord, this.isActivatable);\n                    break;\n                // Activate the previous item\n                case NavigableKeys.ArrowUp:\n                case inlinePrevious:\n                    activatePreviousItem(items, activeItemRecord, this.isActivatable);\n                    break;\n                // Activate the first item\n                case NavigableKeys.Home:\n                    activateFirstItem(items, this.isActivatable);\n                    break;\n                // Activate the last item\n                case NavigableKeys.End:\n                    activateLastItem(items, this.isActivatable);\n                    break;\n                default:\n                    break;\n            }\n        };\n        /**\n         * Listener to be bound to the `deactivate-items` item event.\n         */\n        this.onDeactivateItems = () => {\n            const items = this.items;\n            for (const item of items) {\n                this.deactivateItem(item);\n            }\n        };\n        /**\n         * Listener to be bound to the `request-activation` item event..\n         */\n        this.onRequestActivation = (event) => {\n            this.onDeactivateItems();\n            const target = event.target;\n            this.activateItem(target);\n            target.focus();\n        };\n        /**\n         * Listener to be bound to the `slotchange` event for the slot that renders\n         * the items.\n         */\n        this.onSlotchange = () => {\n            const items = this.items;\n            // Whether we have encountered an item that has been activated\n            let encounteredActivated = false;\n            for (const item of items) {\n                const isActivated = !item.disabled && item.tabIndex > -1;\n                if (isActivated && !encounteredActivated) {\n                    encounteredActivated = true;\n                    item.tabIndex = 0;\n                    continue;\n                }\n                // Deactivate the rest including disabled\n                item.tabIndex = -1;\n            }\n            if (encounteredActivated) {\n                return;\n            }\n            const firstActivatableItem = getFirstActivatableItem(items, this.isActivatable);\n            if (!firstActivatableItem) {\n                return;\n            }\n            firstActivatableItem.tabIndex = 0;\n        };\n        const { isItem, getPossibleItems, isRtl, deactivateItem, activateItem, isNavigableKey, isActivatable, } = config;\n        this.isItem = isItem;\n        this.getPossibleItems = getPossibleItems;\n        this.isRtl = isRtl;\n        this.deactivateItem = deactivateItem;\n        this.activateItem = activateItem;\n        this.isNavigableKey = isNavigableKey;\n        this.isActivatable = isActivatable;\n    }\n    /**\n     * The items being managed by the list. Additionally, attempts to see if the\n     * object has a sub-item in the `.item` property.\n     */\n    get items() {\n        const maybeItems = this.getPossibleItems();\n        const items = [];\n        for (const itemOrParent of maybeItems) {\n            const isItem = this.isItem(itemOrParent);\n            // if the item is a list item, add it to the list of items\n            if (isItem) {\n                items.push(itemOrParent);\n                continue;\n            }\n            // If the item exposes an `item` property check if it is a list item.\n            const subItem = itemOrParent.item;\n            if (subItem && this.isItem(subItem)) {\n                items.push(subItem);\n            }\n        }\n        return items;\n    }\n    /**\n     * Activates the next item in the list. If at the end of the list, the first\n     * item will be activated.\n     *\n     * @return The activated list item or `null` if there are no items.\n     */\n    activateNextItem() {\n        const items = this.items;\n        const activeItemRecord = getActiveItem(items, this.isActivatable);\n        if (activeItemRecord) {\n            activeItemRecord.item.tabIndex = -1;\n        }\n        return activateNextItem(items, activeItemRecord, this.isActivatable);\n    }\n    /**\n     * Activates the previous item in the list. If at the start of the list, the\n     * last item will be activated.\n     *\n     * @return The activated list item or `null` if there are no items.\n     */\n    activatePreviousItem() {\n        const items = this.items;\n        const activeItemRecord = getActiveItem(items, this.isActivatable);\n        if (activeItemRecord) {\n            activeItemRecord.item.tabIndex = -1;\n        }\n        return activatePreviousItem(items, activeItemRecord, this.isActivatable);\n    }\n}\n//# sourceMappingURL=list-controller.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Creates an event that closes any parent menus.\n */\nexport function createCloseMenuEvent(initiator, reason) {\n    return new CustomEvent('close-menu', {\n        bubbles: true,\n        composed: true,\n        detail: { initiator, reason, itemPath: [initiator] }\n    });\n}\n/**\n * Creates an event that signals to the menu that it should stay open on the\n * focusout event.\n */\nexport function createStayOpenOnFocusoutEvent() {\n    return new Event('stay-open-on-focusout', { bubbles: true, composed: true });\n}\n/**\n * Creates an event that signals to the menu that it should close open on the\n * focusout event.\n */\nexport function createCloseOnFocusoutEvent() {\n    return new Event('close-on-focusout', { bubbles: true, composed: true });\n}\n/**\n * Creates a default close menu event used by md-menu.\n */\nexport const createDefaultCloseMenuEvent = (createCloseMenuEvent);\n/**\n * Creates an event that requests the given item be selected.\n */\nexport function createDeactivateTypeaheadEvent() {\n    return new Event('deactivate-typeahead', { bubbles: true, composed: true });\n}\n/**\n * Creates an event that requests the typeahead functionality of containing menu\n * be activated.\n */\nexport function createActivateTypeaheadEvent() {\n    return new Event('activate-typeahead', { bubbles: true, composed: true });\n}\n/**\n * Keys that are used to navigate menus.\n */\n// tslint:disable-next-line:enforce-name-casing We are mimicking enum style\nexport const NavigableKey = {\n    UP: 'ArrowUp',\n    DOWN: 'ArrowDown',\n    RIGHT: 'ArrowRight',\n    LEFT: 'ArrowLeft',\n};\n/**\n * Keys that are used for selection in menus.\n */\n// tslint:disable-next-line:enforce-name-casing We are mimicking enum style\nexport const SelectionKey = {\n    SPACE: 'Space',\n    ENTER: 'Enter',\n};\n/**\n * Default close `Reason` kind values.\n */\n// tslint:disable-next-line:enforce-name-casing We are mimicking enum style\nexport const CloseReason = {\n    CLICK_SELECTION: 'click-selection',\n    KEYDOWN: 'keydown',\n};\n/**\n * Keys that can close menus.\n */\n// tslint:disable-next-line:enforce-name-casing We are mimicking enum style\nexport const KeydownCloseKey = {\n    ESCAPE: 'Escape',\n    SPACE: SelectionKey.SPACE,\n    ENTER: SelectionKey.ENTER,\n};\n/**\n * Determines whether the given key code is a key code that should close the\n * menu.\n *\n * @param code The KeyboardEvent code to check.\n * @return Whether or not the key code is in the predetermined list to close the\n * menu.\n */\nexport function isClosableKey(code) {\n    return Object.values(KeydownCloseKey).some(value => (value === code));\n}\n/**\n * Determines whether the given key code is a key code that should select a menu\n * item.\n *\n * @param code They KeyboardEvent code to check.\n * @return Whether or not the key code is in the predetermined list to select a\n * menu item.\n */\nexport function isSelectableKey(code) {\n    return Object.values(SelectionKey).some(value => (value === code));\n}\n/**\n * Determines whether a target element is contained inside another element's\n * composed tree.\n *\n * @param target The potential contained element.\n * @param container The potential containing element of the target.\n * @returns Whether the target element is contained inside the container's\n * composed subtree\n */\nexport function isElementInSubtree(target, container) {\n    // Dispatch a composed, bubbling event to check its path to see if the\n    // newly-focused element is contained in container's subtree\n    const focusEv = new Event('md-contains', { bubbles: true, composed: true });\n    let composedPath = [];\n    const listener = (ev) => {\n        composedPath = ev.composedPath();\n    };\n    container.addEventListener('md-contains', listener);\n    target.dispatchEvent(focusEv);\n    container.removeEventListener('md-contains', listener);\n    const isContained = composedPath.length > 0;\n    return isContained;\n}\n/**\n * Element to focus on when menu is first opened.\n */\n// tslint:disable-next-line:enforce-name-casing We are mimicking enum style\nexport const FocusState = {\n    NONE: 'none',\n    LIST_ROOT: 'list-root',\n    FIRST_ITEM: 'first-item',\n    LAST_ITEM: 'last-item'\n};\n//# sourceMappingURL=shared.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * An enum of supported Menu corners\n */\n// tslint:disable-next-line:enforce-name-casing We are mimicking enum style\nexport const Corner = {\n    END_START: 'end-start',\n    END_END: 'end-end',\n    START_START: 'start-start',\n    START_END: 'start-end',\n};\n/**\n * Given a surface, an anchor, corners, and some options, this surface will\n * calculate the position of a surface to align the two given corners and keep\n * the surface inside the window viewport. It also provides a StyleInfo map that\n * can be applied to the surface to handle visiblility and position.\n */\nexport class SurfacePositionController {\n    /**\n     * @param host The host to connect the controller to.\n     * @param getProperties A function that returns the properties for the\n     * controller.\n     */\n    constructor(host, getProperties) {\n        this.host = host;\n        this.getProperties = getProperties;\n        // The current styles to apply to the surface.\n        this.surfaceStylesInternal = {\n            'display': 'none',\n        };\n        // Previous values stored for change detection. Open change detection is\n        // calculated separately so initialize it here.\n        this.lastValues = { isOpen: false };\n        this.host.addController(this);\n    }\n    /**\n     * The StyleInfo map to apply to the surface via Lit's stylemap\n     */\n    get surfaceStyles() {\n        return this.surfaceStylesInternal;\n    }\n    /**\n     * Calculates the surface's new position required so that the surface's\n     * `surfaceCorner` aligns to the anchor's `anchorCorner` while keeping the\n     * surface inside the window viewport. This positioning also respects RTL by\n     * checking `getComputedStyle()` on the surface element.\n     */\n    async position() {\n        const { surfaceEl, anchorEl, anchorCorner: anchorCornerRaw, surfaceCorner: surfaceCornerRaw, positioning, xOffset, yOffset, repositionStrategy, } = this.getProperties();\n        const anchorCorner = anchorCornerRaw.toLowerCase().trim();\n        const surfaceCorner = surfaceCornerRaw.toLowerCase().trim();\n        if (!surfaceEl || !anchorEl) {\n            return;\n        }\n        // Paint the surface transparently so that we can get the position and the\n        // rect info of the surface.\n        this.surfaceStylesInternal = {\n            'display': 'block',\n            'opacity': '0',\n        };\n        // Wait for it to be visible.\n        this.host.requestUpdate();\n        await this.host.updateComplete;\n        const surfaceRect = surfaceEl.getSurfacePositionClientRect ?\n            surfaceEl.getSurfacePositionClientRect() :\n            surfaceEl.getBoundingClientRect();\n        const anchorRect = anchorEl.getSurfacePositionClientRect ?\n            anchorEl.getSurfacePositionClientRect() :\n            anchorEl.getBoundingClientRect();\n        const [surfaceBlock, surfaceInline] = surfaceCorner.split('-');\n        const [anchorBlock, anchorInline] = anchorCorner.split('-');\n        // LTR depends on the direction of the SURFACE not the anchor.\n        const isLTR = getComputedStyle(surfaceEl).direction === 'ltr';\n        /*\n         * A diagram that helps describe some of the variables used in the following\n         * calculations.\n         *\n         * ┌───── inline/blockTopLayerOffset\n         * │       │\n         * │     ┌─▼───┐                  Window\n         * │    ┌┼─────┴────────────────────────┐\n         * │    ││                              │\n         * └──► ││  ┌──inline/blockAnchorOffset │\n         *      ││  │     │                     │\n         *      └┤  │  ┌──▼───┐                 │\n         *       │  │ ┌┼──────┤                 │\n         *       │  └─►│Anchor│                 │\n         *       │    └┴──────┘                 │\n         *       │                              │\n         *       │     ┌────────────────────────┼────┐\n         *       │     │ Surface                │    │\n         *       │     │                        │    │\n         *       │     │                        │    │\n         *       │     │                        │    │\n         *       │     │                        │    │\n         *       │     │                        │    │\n         *       └─────┼────────────────────────┘    ├┐\n         *             │ inline/blockOOBCorrection   ││\n         *             │                         │   ││\n         *             │                         ├──►││\n         *             │                         │   ││\n         *             └────────────────────────┐▼───┼┘\n         *                                      └────┘\n         */\n        // Calculate the block positioning properties\n        let { blockInset, blockOutOfBoundsCorrection, surfaceBlockProperty } = this.calculateBlock({\n            surfaceRect,\n            anchorRect,\n            anchorBlock,\n            surfaceBlock,\n            yOffset,\n            positioning\n        });\n        // If the surface should be out of bounds in the block direction, flip the\n        // surface and anchor corner block values and recalculate\n        if (blockOutOfBoundsCorrection) {\n            const flippedSurfaceBlock = surfaceBlock === 'start' ? 'end' : 'start';\n            const flippedAnchorBlock = anchorBlock === 'start' ? 'end' : 'start';\n            const flippedBlock = this.calculateBlock({\n                surfaceRect,\n                anchorRect,\n                anchorBlock: flippedAnchorBlock,\n                surfaceBlock: flippedSurfaceBlock,\n                yOffset,\n                positioning\n            });\n            // In the case that the flipped verion would require less out of bounds\n            // correcting, use the flipped corner block values\n            if (blockOutOfBoundsCorrection >\n                flippedBlock.blockOutOfBoundsCorrection) {\n                blockInset = flippedBlock.blockInset;\n                blockOutOfBoundsCorrection = flippedBlock.blockOutOfBoundsCorrection;\n                surfaceBlockProperty = flippedBlock.surfaceBlockProperty;\n            }\n        }\n        // Calculate the inline positioning properties\n        let { inlineInset, inlineOutOfBoundsCorrection, surfaceInlineProperty } = this.calculateInline({\n            surfaceRect,\n            anchorRect,\n            anchorInline,\n            surfaceInline,\n            xOffset,\n            positioning,\n            isLTR,\n        });\n        // If the surface should be out of bounds in the inline direction, flip the\n        // surface and anchor corner inline values and recalculate\n        if (inlineOutOfBoundsCorrection) {\n            const flippedSurfaceInline = surfaceInline === 'start' ? 'end' : 'start';\n            const flippedAnchorInline = anchorInline === 'start' ? 'end' : 'start';\n            const flippedInline = this.calculateInline({\n                surfaceRect,\n                anchorRect,\n                anchorInline: flippedAnchorInline,\n                surfaceInline: flippedSurfaceInline,\n                xOffset,\n                positioning,\n                isLTR,\n            });\n            // In the case that the flipped verion would require less out of bounds\n            // correcting, use the flipped corner inline values\n            if (Math.abs(inlineOutOfBoundsCorrection) >\n                Math.abs(flippedInline.inlineOutOfBoundsCorrection)) {\n                inlineInset = flippedInline.inlineInset;\n                inlineOutOfBoundsCorrection = flippedInline.inlineOutOfBoundsCorrection;\n                surfaceInlineProperty = flippedInline.surfaceInlineProperty;\n            }\n        }\n        // If we are simply repositioning the surface back inside the viewport,\n        // subtract the out of bounds correction values from the positioning.\n        if (repositionStrategy === 'move') {\n            blockInset = blockInset - blockOutOfBoundsCorrection;\n            inlineInset = inlineInset - inlineOutOfBoundsCorrection;\n        }\n        this.surfaceStylesInternal = {\n            'display': 'block',\n            'opacity': '1',\n            [surfaceBlockProperty]: `${blockInset}px`,\n            [surfaceInlineProperty]: `${inlineInset}px`,\n        };\n        // In the case that we are resizing the surface to stay inside the viewport\n        // we need to set height and width on the surface.\n        if (repositionStrategy === 'resize') {\n            // Add a height property to the styles if there is block height correction\n            if (blockOutOfBoundsCorrection) {\n                this.surfaceStylesInternal['height'] =\n                    `${surfaceRect.height - blockOutOfBoundsCorrection}px`;\n            }\n            // Add a width property to the styles if there is block height correction\n            if (inlineOutOfBoundsCorrection) {\n                this.surfaceStylesInternal['width'] =\n                    `${surfaceRect.width - inlineOutOfBoundsCorrection}px`;\n            }\n        }\n        this.host.requestUpdate();\n    }\n    /**\n     * Calculates the css property, the inset, and the out of bounds correction\n     * for the surface in the block direction.\n     */\n    calculateBlock(config) {\n        const { surfaceRect, anchorRect, anchorBlock, surfaceBlock, yOffset, positioning, } = config;\n        // We use number booleans to multiply values rather than `if` / ternary\n        // statements because it _heavily_ cuts down on nesting and readability\n        const relativeToWindow = positioning === 'fixed' ? 1 : 0;\n        const isSurfaceBlockStart = surfaceBlock === 'start' ? 1 : 0;\n        const isSurfaceBlockEnd = surfaceBlock === 'end' ? 1 : 0;\n        const isOneBlockEnd = anchorBlock !== surfaceBlock ? 1 : 0;\n        // Whether or not to apply the height of the anchor\n        const blockAnchorOffset = isOneBlockEnd * anchorRect.height + yOffset;\n        // The absolute block position of the anchor relative to window\n        const blockTopLayerOffset = isSurfaceBlockStart * anchorRect.top +\n            isSurfaceBlockEnd * (window.innerHeight - anchorRect.bottom);\n        // If the surface's block would be out of bounds of the window, move it back\n        // in\n        const blockOutOfBoundsCorrection = Math.abs(Math.min(0, window.innerHeight - blockTopLayerOffset - blockAnchorOffset -\n            surfaceRect.height));\n        // The block logical value of the surface\n        const blockInset = relativeToWindow * blockTopLayerOffset + blockAnchorOffset;\n        const surfaceBlockProperty = surfaceBlock === 'start' ? 'inset-block-start' : 'inset-block-end';\n        return { blockInset, blockOutOfBoundsCorrection, surfaceBlockProperty };\n    }\n    /**\n     * Calculates the css property, the inset, and the out of bounds correction\n     * for the surface in the inline direction.\n     */\n    calculateInline(config) {\n        const { isLTR: isLTRBool, surfaceInline, anchorInline, anchorRect, surfaceRect, xOffset, positioning, } = config;\n        // We use number booleans to multiply values rather than `if` / ternary\n        // statements because it _heavily_ cuts down on nesting and readability\n        const relativeToWindow = positioning === 'fixed' ? 1 : 0;\n        const isLTR = isLTRBool ? 1 : 0;\n        const isRTL = isLTRBool ? 0 : 1;\n        const isSurfaceInlineStart = surfaceInline === 'start' ? 1 : 0;\n        const isSurfaceInlineEnd = surfaceInline === 'end' ? 1 : 0;\n        const isOneInlineEnd = anchorInline !== surfaceInline ? 1 : 0;\n        // Whether or not to apply the width of the anchor\n        const inlineAnchorOffset = isOneInlineEnd * anchorRect.width + xOffset;\n        // The inline position of the anchor relative to window in LTR\n        const inlineTopLayerOffsetLTR = isSurfaceInlineStart * anchorRect.left +\n            isSurfaceInlineEnd * (window.innerWidth - anchorRect.right);\n        // The inline position of the anchor relative to window in RTL\n        const inlineTopLayerOffsetRTL = isSurfaceInlineStart * (window.innerWidth - anchorRect.right) +\n            isSurfaceInlineEnd * anchorRect.left;\n        // The inline position of the anchor relative to window\n        const inlineTopLayerOffset = isLTR * inlineTopLayerOffsetLTR + isRTL * inlineTopLayerOffsetRTL;\n        // If the surface's inline would be out of bounds of the window, move it\n        // back in\n        const inlineOutOfBoundsCorrection = Math.abs(Math.min(0, window.innerWidth - inlineTopLayerOffset - inlineAnchorOffset -\n            surfaceRect.width));\n        // The inline logical value of the surface\n        const inlineInset = relativeToWindow * inlineTopLayerOffset + inlineAnchorOffset;\n        const surfaceInlineProperty = surfaceInline === 'start' ? 'inset-inline-start' : 'inset-inline-end';\n        return {\n            inlineInset,\n            inlineOutOfBoundsCorrection,\n            surfaceInlineProperty,\n        };\n    }\n    hostUpdate() {\n        this.onUpdate();\n    }\n    hostUpdated() {\n        this.onUpdate();\n    }\n    /**\n     * Checks whether the properties passed into the controller have changed since\n     * the last positioning. If so, it will reposition if the surface is open or\n     * close it if the surface should close.\n     */\n    async onUpdate() {\n        const props = this.getProperties();\n        let hasChanged = false;\n        for (const [key, value] of Object.entries(props)) {\n            // tslint:disable-next-line\n            hasChanged = hasChanged || (value !== this.lastValues[key]);\n            if (hasChanged)\n                break;\n        }\n        const openChanged = this.lastValues.isOpen !== props.isOpen;\n        const hasAnchor = !!props.anchorEl;\n        const hasSurface = !!props.surfaceEl;\n        if (hasChanged && hasAnchor && hasSurface) {\n            // Only update isOpen, because if it's closed, we do not want to waste\n            // time on a useless reposition calculation. So save the other \"dirty\"\n            // values until next time it opens.\n            this.lastValues.isOpen = props.isOpen;\n            if (props.isOpen) {\n                // We are going to do a reposition, so save the prop values for future\n                // dirty checking.\n                this.lastValues = props;\n                await this.position();\n                props.onOpen();\n            }\n            else if (openChanged) {\n                await props.beforeClose();\n                this.close();\n                props.onClose();\n            }\n        }\n    }\n    /**\n     * Hides the surface.\n     */\n    close() {\n        this.surfaceStylesInternal = {\n            'display': 'none',\n        };\n        this.host.requestUpdate();\n    }\n}\n//# sourceMappingURL=surfacePositionController.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Indicies to access the TypeaheadRecord tuple type.\n */\nexport const TYPEAHEAD_RECORD = {\n    INDEX: 0,\n    ITEM: 1,\n    TEXT: 2,\n};\n/**\n * This controller listens to `keydown` events and searches the header text of\n * an array of `MenuItem`s with the corresponding entered keys within the buffer\n * time and activates the item.\n *\n * @example\n * ```ts\n * const typeaheadController = new TypeaheadController(() => ({\n *   typeaheadBufferTime: 50,\n *   getItems: () => Array.from(document.querySelectorAll('md-menu-item'))\n * }));\n * html`\n *   <div\n *       @keydown=${typeaheadController.onKeydown}\n *       tabindex=\"0\"\n *       class=\"activeItemText\">\n *     <!-- focusable element that will receive keydown events -->\n *     Apple\n *   </div>\n *   <div>\n *     <md-menu-item active header=\"Apple\"></md-menu-item>\n *     <md-menu-item header=\"Apricot\"></md-menu-item>\n *     <md-menu-item header=\"Banana\"></md-menu-item>\n *     <md-menu-item header=\"Olive\"></md-menu-item>\n *     <md-menu-item header=\"Orange\"></md-menu-item>\n *   </div>\n * `;\n * ```\n */\nexport class TypeaheadController {\n    /**\n     * @param getProperties A function that returns the options of the typeahead\n     * controller:\n     *\n     * {\n     *   getItems: A function that returns an array of menu items to be searched.\n     *   typeaheadBufferTime: The maximum time between each keystroke to keep the\n     *       current type buffer alive.\n     * }\n     */\n    constructor(getProperties) {\n        this.getProperties = getProperties;\n        /**\n         * Array of tuples that helps with indexing.\n         */\n        this.typeaheadRecords = [];\n        /**\n         * Currently-typed text since last buffer timeout\n         */\n        this.typaheadBuffer = '';\n        /**\n         * The timeout id from the current buffer's setTimeout\n         */\n        this.cancelTypeaheadTimeout = 0;\n        /**\n         * If we are currently \"typing\"\n         */\n        this.isTypingAhead = false;\n        /**\n         * The record of the last active item.\n         */\n        this.lastActiveRecord = null;\n        /**\n         * Apply this listener to the element that will receive `keydown` events that\n         * should trigger this controller.\n         *\n         * @param event The native browser `KeyboardEvent` from the `keydown` event.\n         */\n        this.onKeydown = (event) => {\n            if (this.isTypingAhead) {\n                this.typeahead(event);\n            }\n            else {\n                this.beginTypeahead(event);\n            }\n        };\n        /**\n         * Ends the current typeahead and clears the buffer.\n         */\n        this.endTypeahead = () => {\n            this.isTypingAhead = false;\n            this.typaheadBuffer = '';\n            this.typeaheadRecords = [];\n        };\n    }\n    get items() {\n        return this.getProperties().getItems();\n    }\n    get active() {\n        return this.getProperties().active;\n    }\n    /**\n     * Sets up typingahead\n     */\n    beginTypeahead(event) {\n        if (!this.active) {\n            return;\n        }\n        // We don't want to typeahead if the _beginning_ of the typeahead is a menu\n        // navigation, or a selection. We will handle \"Space\" only if it's in the\n        // middle of a typeahead\n        if (event.code === 'Space' || event.code === 'Enter' ||\n            event.code.startsWith('Arrow') || event.code === 'Escape') {\n            return;\n        }\n        this.isTypingAhead = true;\n        // Generates the record array data structure which is the index, the element\n        // and a normalized header.\n        this.typeaheadRecords = this.items.map((el, index) => [index, el, el.typeaheadText.trim().toLowerCase()]);\n        this.lastActiveRecord =\n            this.typeaheadRecords.find(record => (record[TYPEAHEAD_RECORD.ITEM].tabIndex === 0)) ??\n                null;\n        if (this.lastActiveRecord) {\n            this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;\n        }\n        this.typeahead(event);\n    }\n    /**\n     * Performs the typeahead. Based on the normalized items and the current text\n     * buffer, finds the _next_ item with matching text and activates it.\n     *\n     * @example\n     *\n     * items: Apple, Banana, Olive, Orange, Cucumber\n     * buffer: ''\n     * user types: o\n     *\n     * activates Olive\n     *\n     * @example\n     *\n     * items: Apple, Banana, Olive (active), Orange, Cucumber\n     * buffer: 'o'\n     * user types: l\n     *\n     * activates Olive\n     *\n     * @example\n     *\n     * items: Apple, Banana, Olive (active), Orange, Cucumber\n     * buffer: ''\n     * user types: o\n     *\n     * activates Orange\n     *\n     * @example\n     *\n     * items: Apple, Banana, Olive, Orange (active), Cucumber\n     * buffer: ''\n     * user types: o\n     *\n     * activates Olive\n     */\n    typeahead(event) {\n        if (event.defaultPrevented)\n            return;\n        clearTimeout(this.cancelTypeaheadTimeout);\n        // Stop typingahead if one of the navigation or selection keys (except for\n        // Space) are pressed\n        if (event.code === 'Enter' || event.code.startsWith('Arrow') ||\n            event.code === 'Escape') {\n            this.endTypeahead();\n            if (this.lastActiveRecord) {\n                this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;\n            }\n            return;\n        }\n        // If Space is pressed, prevent it from selecting and closing the menu\n        if (event.code === 'Space') {\n            event.preventDefault();\n        }\n        // Start up a new keystroke buffer timeout\n        this.cancelTypeaheadTimeout =\n            setTimeout(this.endTypeahead, this.getProperties().typeaheadBufferTime);\n        this.typaheadBuffer += event.key.toLowerCase();\n        const lastActiveIndex = this.lastActiveRecord ?\n            this.lastActiveRecord[TYPEAHEAD_RECORD.INDEX] :\n            -1;\n        const numRecords = this.typeaheadRecords.length;\n        /**\n         * Sorting function that will resort the items starting with the given index\n         *\n         * @example\n         *\n         * this.typeaheadRecords =\n         * 0: [0, <reference>, 'apple']\n         * 1: [1, <reference>, 'apricot']\n         * 2: [2, <reference>, 'banana']\n         * 3: [3, <reference>, 'olive'] <-- lastActiveIndex\n         * 4: [4, <reference>, 'orange']\n         * 5: [5, <reference>, 'strawberry']\n         *\n         * this.typeaheadRecords.sort((a,b) => rebaseIndexOnActive(a)\n         *                                       - rebaseIndexOnActive(b)) ===\n         * 0: [3, <reference>, 'olive'] <-- lastActiveIndex\n         * 1: [4, <reference>, 'orange']\n         * 2: [5, <reference>, 'strawberry']\n         * 3: [0, <reference>, 'apple']\n         * 4: [1, <reference>, 'apricot']\n         * 5: [2, <reference>, 'banana']\n         */\n        const rebaseIndexOnActive = (record) => {\n            return (record[TYPEAHEAD_RECORD.INDEX] + numRecords - lastActiveIndex) %\n                numRecords;\n        };\n        // records filtered and sorted / rebased around the last active index\n        const matchingRecords = this.typeaheadRecords\n            .filter(record => !record[TYPEAHEAD_RECORD.ITEM].disabled &&\n            record[TYPEAHEAD_RECORD.TEXT].startsWith(this.typaheadBuffer))\n            .sort((a, b) => rebaseIndexOnActive(a) - rebaseIndexOnActive(b));\n        // Just leave if there's nothing that matches. Native select will just\n        // choose the first thing that starts with the next letter in the alphabet\n        // but that's out of scope and hard to localize\n        if (matchingRecords.length === 0) {\n            clearTimeout(this.cancelTypeaheadTimeout);\n            if (this.lastActiveRecord) {\n                this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;\n            }\n            this.endTypeahead();\n            return;\n        }\n        const isNewQuery = this.typaheadBuffer.length === 1;\n        let nextRecord;\n        // This is likely the case that someone is trying to \"tab\" through different\n        // entries that start with the same letter\n        if (this.lastActiveRecord === matchingRecords[0] && isNewQuery) {\n            nextRecord = matchingRecords[1] ?? matchingRecords[0];\n        }\n        else {\n            nextRecord = matchingRecords[0];\n        }\n        if (this.lastActiveRecord) {\n            this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;\n        }\n        this.lastActiveRecord = nextRecord;\n        nextRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = 0;\n        nextRecord[TYPEAHEAD_RECORD.ITEM].focus();\n        return;\n    }\n}\n//# sourceMappingURL=typeaheadController.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport '../../focus/md-focus-ring.js';\nimport '../../elevation/elevation.js';\nimport { html, isServer, LitElement } from 'lit';\nimport { property, query, queryAssignedElements, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { styleMap } from 'lit/directives/style-map.js';\nimport { polyfillElementInternalsAria, setupHostAria } from '../../internal/aria/aria.js';\nimport { createAnimationSignal, EASING } from '../../internal/motion/animation.js';\nimport { ListController, NavigableKeys } from '../../list/internal/list-controller.js';\nimport { getActiveItem, getFirstActivatableItem, getLastActivatableItem } from '../../list/internal/list-navigation-helpers.js';\nimport { FocusState, isClosableKey, isElementInSubtree } from './controllers/shared.js';\nimport { Corner, SurfacePositionController } from './controllers/surfacePositionController.js';\nimport { TypeaheadController } from './controllers/typeaheadController.js';\nexport { Corner } from './controllers/surfacePositionController.js';\n/**\n * The default value for the typeahead buffer time in Milliseconds.\n */\nexport const DEFAULT_TYPEAHEAD_BUFFER_TIME = 200;\nconst submenuNavKeys = new Set([\n    NavigableKeys.ArrowDown,\n    NavigableKeys.ArrowUp,\n    NavigableKeys.Home,\n    NavigableKeys.End,\n]);\nconst menuNavKeys = new Set([\n    NavigableKeys.ArrowLeft,\n    NavigableKeys.ArrowRight,\n    ...submenuNavKeys,\n]);\n/**\n * Gets the currently focused element on the page.\n *\n * @param activeDoc The document or shadowroot from which to start the search.\n *    Defaults to `window.document`\n * @return Returns the currently deeply focused element or `null` if none.\n */\nfunction getFocusedElement(activeDoc = document) {\n    let activeEl = activeDoc.activeElement;\n    // Check for activeElement in the case that an element with a shadow root host\n    // is currently focused.\n    while (activeEl && activeEl?.shadowRoot?.activeElement) {\n        activeEl = activeEl.shadowRoot.activeElement;\n    }\n    return activeEl;\n}\n/**\n * @fires opening Fired before the opening animation begins\n * @fires opened Fired once the menu is open, after any animations\n * @fires closing Fired before the closing animation begins\n * @fires closed Fired once the menu is closed, after any animations\n */\nexport class Menu extends LitElement {\n    /**\n     * Whether the menu is animating upwards or downwards when opening. This is\n     * helpful for calculating some animation calculations.\n     */\n    get openDirection() {\n        const menuCornerBlock = this.menuCorner.split('_')[0];\n        return menuCornerBlock === 'START' ? 'DOWN' : 'UP';\n    }\n    /**\n     * The element which the menu should align to. If `anchor` is set to a\n     * non-empty idref string, then `anchorEl` will resolve to the element with\n     * the given id in the same root node. Otherwise, `null`.\n     */\n    get anchorElement() {\n        if (this.anchor) {\n            return this.getRootNode()\n                .querySelector(`#${this.anchor}`);\n        }\n        return this.currentAnchorElement;\n    }\n    set anchorElement(element) {\n        this.currentAnchorElement = element;\n        this.requestUpdate('anchorElement');\n    }\n    constructor() {\n        super();\n        /**\n         * The ID of the element in the same root node in which the menu should align\n         * to. Overrides setting `anchorElement = elementReference`.\n         *\n         * __NOTE__: anchor or anchorElement must either be an HTMLElement or resolve\n         * to an HTMLElement in order for menu to open.\n         */\n        this.anchor = '';\n        /**\n         * Whether the positioning algorithim should calculate relative to the parent\n         * of the anchor element (absolute) or relative to the window (fixed).\n         *\n         * Examples for `position = 'fixed'`:\n         *\n         * - If there is no `position:relative` in the given parent tree and the\n         *   surface is `position:absolute`\n         * - If the surface is `position:fixed`\n         * - If the surface is in the \"top layer\"\n         * - The anchor and the surface do not share a common `position:relative`\n         *   ancestor\n         *\n         * When using positioning = fixed, in most cases, the menu should position\n         * itself above most other `position:absolute` or `position:fixed` elements\n         * when placed inside of them. e.g. using a menu inside of an `md-dialog`.\n         *\n         * __NOTE__: Fixed menus will not scroll with the page and will be fixed to\n         * the window instead.\n         */\n        this.positioning = 'absolute';\n        /**\n         * Skips the opening and closing animations.\n         */\n        this.quick = false;\n        /**\n         * Displays overflow content like a submenu.\n         *\n         * __NOTE__: This may cause adverse effects if you set\n         * `md-menu {max-height:...}`\n         * and have items overflowing items in the \"y\" direction.\n         */\n        this.hasOverflow = false;\n        /**\n         * Opens the menu and makes it visible. Alternative to the `.show()` and\n         * `.close()` methods\n         */\n        this.open = false;\n        /**\n         * Offsets the menu's inline alignment from the anchor by the given number in\n         * pixels. This value is direction aware and will follow the LTR / RTL\n         * direction.\n         *\n         * e.g. LTR: positive -> right, negative -> left\n         *      RTL: positive -> left, negative -> right\n         */\n        this.xOffset = 0;\n        /**\n         * Offsets the menu's block alignment from the anchor by the given number in\n         * pixels.\n         *\n         * e.g. positive -> down, negative -> up\n         */\n        this.yOffset = 0;\n        /**\n         * The max time between the keystrokes of the typeahead menu behavior before\n         * it clears the typeahead buffer.\n         */\n        this.typeaheadDelay = DEFAULT_TYPEAHEAD_BUFFER_TIME;\n        /**\n         * The corner of the anchor which to align the menu in the standard logical\n         * property style of <block>-<inline> e.g. `'end-start'`.\n         *\n         * NOTE: This value may not be respected by the menu positioning algorithm\n         * if the menu would render outisde the viewport.\n         */\n        this.anchorCorner = Corner.END_START;\n        /**\n         * The corner of the menu which to align the anchor in the standard logical\n         * property style of <block>-<inline> e.g. `'start-start'`.\n         *\n         * NOTE: This value may not be respected by the menu positioning algorithm\n         * if the menu would render outisde the viewport.\n         */\n        this.menuCorner = Corner.START_START;\n        /**\n         * Keeps the user clicks outside the menu.\n         *\n         * NOTE: clicking outside may still cause focusout to close the menu so see\n         * `stayOpenOnFocusout`.\n         */\n        this.stayOpenOnOutsideClick = false;\n        /**\n         * Keeps the menu open when focus leaves the menu's composed subtree.\n         *\n         * NOTE: Focusout behavior will stop propagation of the focusout event. Set\n         * this property to true to opt-out of menu's focuout handling altogether.\n         */\n        this.stayOpenOnFocusout = false;\n        /**\n         * After closing, does not restore focus to the last focused element before\n         * the menu was opened.\n         */\n        this.skipRestoreFocus = false;\n        /**\n         * The element that should be focused by default once opened.\n         *\n         * NOTE: When setting default focus to 'LIST_ROOT', remember to change\n         * `tabindex` to `0` and change md-menu's display to something other than\n         * `display: contents` when necessary.\n         */\n        this.defaultFocus = FocusState.FIRST_ITEM;\n        this.typeaheadActive = true;\n        /**\n         * Whether or not the current menu is a submenu and should not handle specific\n         * navigation keys.\n         *\n         * @exports\n         */\n        this.isSubmenu = false;\n        /**\n         * The event path of the last window pointerdown event.\n         */\n        this.pointerPath = [];\n        this.isPointerDown = false;\n        this.openCloseAnimationSignal = createAnimationSignal();\n        this.listController = new ListController({\n            isItem: (maybeItem) => {\n                return maybeItem.hasAttribute('md-menu-item');\n            },\n            getPossibleItems: () => this.slotItems,\n            isRtl: () => (getComputedStyle(this).direction === 'rtl'),\n            deactivateItem: (item) => {\n                item.selected = false;\n                item.tabIndex = -1;\n            },\n            activateItem: (item) => {\n                item.selected = true;\n                item.tabIndex = 0;\n            },\n            isNavigableKey: (key) => {\n                if (!this.isSubmenu) {\n                    return menuNavKeys.has(key);\n                }\n                const isRtl = getComputedStyle(this).direction === 'rtl';\n                // we want md-submenu to handle the submenu's left/right arrow exit\n                // key so it can close the menu instead of navigate the list.\n                // Therefore we need to include all keys but left/right arrow close\n                // key\n                const arrowOpen = isRtl ? NavigableKeys.ArrowLeft : NavigableKeys.ArrowRight;\n                if (key === arrowOpen) {\n                    return true;\n                }\n                return submenuNavKeys.has(key);\n            },\n        });\n        /**\n         * The element that was focused before the menu opened.\n         */\n        this.lastFocusedElement = null;\n        /**\n         * Handles typeahead navigation through the menu.\n         */\n        this.typeaheadController = new TypeaheadController(() => {\n            return {\n                getItems: () => this.items,\n                typeaheadBufferTime: this.typeaheadDelay,\n                active: this.typeaheadActive\n            };\n        });\n        this.currentAnchorElement = null;\n        this.internals = polyfillElementInternalsAria(this, this /* needed for closure */.attachInternals());\n        /**\n         * Handles positioning the surface and aligning it to the anchor as well as\n         * keeping it in the viewport.\n         */\n        this.menuPositionController = new SurfacePositionController(this, () => {\n            return {\n                anchorCorner: this.anchorCorner,\n                surfaceCorner: this.menuCorner,\n                surfaceEl: this.surfaceEl,\n                anchorEl: this.anchorElement,\n                positioning: this.positioning,\n                isOpen: this.open,\n                xOffset: this.xOffset,\n                yOffset: this.yOffset,\n                onOpen: this.onOpened,\n                beforeClose: this.beforeClose,\n                onClose: this.onClosed,\n                // We can't resize components that have overflow like menus with\n                // submenus because the overflow-y will show menu items / content\n                // outside the bounds of the menu. (to be fixed w/ popover API)\n                repositionStrategy: this.hasOverflow ? 'move' : 'resize',\n            };\n        });\n        this.handleFocusout = async (event) => {\n            if (this.stayOpenOnFocusout || !this.open) {\n                return;\n            }\n            if (event.relatedTarget) {\n                // Don't close the menu if we are switching focus between menu,\n                // md-menu-item, and md-list\n                if (isElementInSubtree(event.relatedTarget, this)) {\n                    return;\n                }\n                const anchorEl = this.anchorElement;\n                const wasAnchorClickFocused = isElementInSubtree(event.relatedTarget, anchorEl) &&\n                    this.isPointerDown;\n                if (wasAnchorClickFocused) {\n                    return;\n                }\n            }\n            else if (this.isPointerDown && this.pointerPath.includes(this)) {\n                // If menu tabindex == -1 and the user clicks on the menu or a divider, we\n                // want to keep the menu open.\n                return;\n            }\n            const oldRestoreFocus = this.skipRestoreFocus;\n            // allow focus to continue to the next focused object rather than returning\n            this.skipRestoreFocus = true;\n            this.close();\n            // await for close\n            await this.updateComplete;\n            // return to previous behavior\n            this.skipRestoreFocus = oldRestoreFocus;\n        };\n        /**\n         * Saves the last focused element focuses the new element based on\n         * `defaultFocus`, and animates open.\n         */\n        this.onOpened = async () => {\n            this.lastFocusedElement = getFocusedElement();\n            const items = this.items;\n            const activeItemRecord = getActiveItem(items);\n            if (activeItemRecord && this.defaultFocus !== FocusState.NONE) {\n                activeItemRecord.item.tabIndex = -1;\n            }\n            let animationAborted = !this.quick;\n            if (this.quick) {\n                this.dispatchEvent(new Event('opening'));\n            }\n            else {\n                animationAborted = !!await this.animateOpen();\n            }\n            // This must come after the opening animation or else it may focus one of\n            // the items before the animation has begun and causes the list to slide\n            // (block-padding-of-the-menu)px at the end of the animation\n            switch (this.defaultFocus) {\n                case FocusState.FIRST_ITEM:\n                    const first = getFirstActivatableItem(items);\n                    if (first) {\n                        first.tabIndex = 0;\n                        first.focus();\n                        await first.updateComplete;\n                    }\n                    break;\n                case FocusState.LAST_ITEM:\n                    const last = getLastActivatableItem(items);\n                    if (last) {\n                        last.tabIndex = 0;\n                        last.focus();\n                        await last.updateComplete;\n                    }\n                    break;\n                case FocusState.LIST_ROOT:\n                    this.focus();\n                    break;\n                default:\n                case FocusState.NONE:\n                    // Do nothing.\n                    break;\n            }\n            if (!animationAborted) {\n                this.dispatchEvent(new Event('opened'));\n            }\n        };\n        /**\n         * Animates closed.\n         */\n        this.beforeClose = async () => {\n            this.open = false;\n            if (!this.skipRestoreFocus) {\n                this.lastFocusedElement?.focus?.();\n            }\n            if (!this.quick) {\n                await this.animateClose();\n            }\n        };\n        /**\n         * Focuses the last focused element.\n         */\n        this.onClosed = () => {\n            if (this.quick) {\n                this.dispatchEvent(new Event('closing'));\n                this.dispatchEvent(new Event('closed'));\n            }\n        };\n        this.onWindowPointerdown = (event) => {\n            this.isPointerDown = true;\n            this.pointerPath = event.composedPath();\n        };\n        this.onWindowPointerup = () => {\n            this.isPointerDown = false;\n        };\n        this.onWindowClick = (event) => {\n            if (!this.open) {\n                return;\n            }\n            const path = event.composedPath();\n            if (!this.stayOpenOnOutsideClick && !path.includes(this) &&\n                !path.includes(this.anchorElement)) {\n                this.open = false;\n            }\n        };\n        if (!isServer) {\n            this.internals.role = 'menu';\n            this.addEventListener('keydown', this.listController.handleKeydown);\n            // Capture so that we can grab the event before it reaches the menu item\n            // istelf. Specifically useful for the case where typeahead encounters a\n            // space and we don't want the menu item to close the menu.\n            this.addEventListener('keydown', this.captureKeydown, { capture: true });\n            this.addEventListener('focusout', this.handleFocusout);\n        }\n    }\n    /**\n     * The menu items associated with this menu. The items must be `MenuItem`s and\n     * have both the `md-menu-item` and `md-list-item` attributes.\n     */\n    get items() {\n        return this.listController.items;\n    }\n    willUpdate(changed) {\n        if (!changed.has('open')) {\n            return;\n        }\n        if (this.open) {\n            this.removeAttribute('aria-hidden');\n            return;\n        }\n        this.setAttribute('aria-hidden', 'true');\n    }\n    render() {\n        return this.renderSurface();\n    }\n    /**\n     * Renders the positionable surface element and its contents.\n     */\n    renderSurface() {\n        return html `\n       <div\n          class=\"menu ${classMap(this.getSurfaceClasses())}\"\n          style=${styleMap(this.menuPositionController.surfaceStyles)}>\n        ${this.renderElevation()}\n        <div class=\"items\">\n          <div class=\"item-padding\">\n            ${this.renderMenuItems()}\n          </div>\n        </div>\n       </div>\n     `;\n    }\n    /**\n     * Renders the menu items' slot\n     */\n    renderMenuItems() {\n        return html `<slot\n        @close-menu=${this.onCloseMenu}\n        @deactivate-items=${this.onDeactivateItems}\n        @request-activation=${this.onRequestActivation}\n        @deactivate-typeahead=${this.handleDeactivateTypeahead}\n        @activate-typeahead=${this.handleActivateTypeahead}\n        @stay-open-on-focusout=${this.handleStayOpenOnFocusout}\n        @close-on-focusout=${this.handleCloseOnFocusout}\n        @slotchange=${this.listController.onSlotchange}></slot>`;\n    }\n    /**\n     * Renders the elevation component.\n     */\n    renderElevation() {\n        return html `<md-elevation part=\"elevation\"></md-elevation>`;\n    }\n    getSurfaceClasses() {\n        return {\n            open: this.open,\n            fixed: this.positioning === 'fixed',\n            'has-overflow': this.hasOverflow,\n        };\n    }\n    captureKeydown(event) {\n        if (event.target === this && !event.defaultPrevented &&\n            isClosableKey(event.code)) {\n            event.preventDefault();\n            this.close();\n        }\n        this.typeaheadController.onKeydown(event);\n    }\n    /**\n     * Performs the opening animation:\n     *\n     * https://direct.googleplex.com/#/spec/295000003+271060003\n     *\n     * @return A promise that resolve to `true` if the animation was aborted,\n     *     `false` if it was not aborted.\n     */\n    async animateOpen() {\n        const surfaceEl = this.surfaceEl;\n        const slotEl = this.slotEl;\n        if (!surfaceEl || !slotEl)\n            return true;\n        const openDirection = this.openDirection;\n        this.dispatchEvent(new Event('opening'));\n        // needs to be imperative because we don't want to mix animation and Lit\n        // render timing\n        surfaceEl.classList.toggle('animating', true);\n        const signal = this.openCloseAnimationSignal.start();\n        const height = surfaceEl.offsetHeight;\n        const openingUpwards = openDirection === 'UP';\n        const children = this.items;\n        const FULL_DURATION = 500;\n        const SURFACE_OPACITY_DURATION = 50;\n        const ITEM_OPACITY_DURATION = 250;\n        // We want to fit every child fade-in animation within the full duration of\n        // the animation.\n        const DELAY_BETWEEN_ITEMS = (FULL_DURATION - ITEM_OPACITY_DURATION) / children.length;\n        const surfaceHeightAnimation = surfaceEl.animate([{ height: '0px' }, { height: `${height}px` }], {\n            duration: FULL_DURATION,\n            easing: EASING.EMPHASIZED,\n        });\n        // When we are opening upwards, we want to make sure the last item is always\n        // in view, so we need to translate it upwards the opposite direction of the\n        // height animation\n        const upPositionCorrectionAnimation = slotEl.animate([\n            { transform: openingUpwards ? `translateY(-${height}px)` : '' },\n            { transform: '' }\n        ], { duration: FULL_DURATION, easing: EASING.EMPHASIZED });\n        const surfaceOpacityAnimation = surfaceEl.animate([{ opacity: 0 }, { opacity: 1 }], SURFACE_OPACITY_DURATION);\n        const childrenAnimations = [];\n        for (let i = 0; i < children.length; i++) {\n            // If we are animating upwards, then reverse the children list.\n            const directionalIndex = openingUpwards ? children.length - 1 - i : i;\n            const child = children[directionalIndex];\n            const animation = child.animate([{ opacity: 0 }, { opacity: 1 }], {\n                duration: ITEM_OPACITY_DURATION,\n                delay: DELAY_BETWEEN_ITEMS * i,\n            });\n            // Make them all initially hidden and then clean up at the end of each\n            // animation.\n            child.classList.toggle('md-menu-hidden', true);\n            animation.addEventListener('finish', () => {\n                child.classList.toggle('md-menu-hidden', false);\n            });\n            childrenAnimations.push([child, animation]);\n        }\n        let resolveAnimation = (value) => { };\n        const animationFinished = new Promise((resolve) => {\n            resolveAnimation = resolve;\n        });\n        signal.addEventListener('abort', () => {\n            surfaceHeightAnimation.cancel();\n            upPositionCorrectionAnimation.cancel();\n            surfaceOpacityAnimation.cancel();\n            childrenAnimations.forEach(([child, animation]) => {\n                child.classList.toggle('md-menu-hidden', false);\n                animation.cancel();\n            });\n            resolveAnimation(true);\n        });\n        surfaceHeightAnimation.addEventListener('finish', () => {\n            surfaceEl.classList.toggle('animating', false);\n            this.openCloseAnimationSignal.finish();\n            resolveAnimation(false);\n        });\n        return await animationFinished;\n    }\n    /**\n     * Performs the closing animation:\n     *\n     * https://direct.googleplex.com/#/spec/295000003+271060003\n     */\n    animateClose() {\n        let resolve;\n        let reject;\n        // This promise blocks the surface position controller from setting\n        // display: none on the surface which will interfere with this animation.\n        const animationEnded = new Promise((res, rej) => {\n            resolve = res;\n            reject = rej;\n        });\n        const surfaceEl = this.surfaceEl;\n        const slotEl = this.slotEl;\n        if (!surfaceEl || !slotEl) {\n            reject();\n            return animationEnded;\n        }\n        const openDirection = this.openDirection;\n        const closingDownwards = openDirection === 'UP';\n        this.dispatchEvent(new Event('closing'));\n        // needs to be imperative because we don't want to mix animation and Lit\n        // render timing\n        surfaceEl.classList.toggle('animating', true);\n        const signal = this.openCloseAnimationSignal.start();\n        const height = surfaceEl.offsetHeight;\n        const children = this.items;\n        const FULL_DURATION = 150;\n        const SURFACE_OPACITY_DURATION = 50;\n        // The surface fades away at the very end\n        const SURFACE_OPACITY_DELAY = FULL_DURATION - SURFACE_OPACITY_DURATION;\n        const ITEM_OPACITY_DURATION = 50;\n        const ITEM_OPACITY_INITIAL_DELAY = 50;\n        const END_HEIGHT_PERCENTAGE = .35;\n        // We want to fit every child fade-out animation within the full duration of\n        // the animation.\n        const DELAY_BETWEEN_ITEMS = (FULL_DURATION - ITEM_OPACITY_INITIAL_DELAY - ITEM_OPACITY_DURATION) /\n            children.length;\n        // The mock has the animation shrink to 35%\n        const surfaceHeightAnimation = surfaceEl.animate([\n            { height: `${height}px` },\n            { height: `${height * END_HEIGHT_PERCENTAGE}px` }\n        ], {\n            duration: FULL_DURATION,\n            easing: EASING.EMPHASIZED_ACCELERATE,\n        });\n        // When we are closing downwards, we want to make sure the last item is\n        // always in view, so we need to translate it upwards the opposite direction\n        // of the height animation\n        const downPositionCorrectionAnimation = slotEl.animate([\n            { transform: '' }, {\n                transform: closingDownwards ?\n                    `translateY(-${height * (1 - END_HEIGHT_PERCENTAGE)}px)` :\n                    ''\n            }\n        ], { duration: FULL_DURATION, easing: EASING.EMPHASIZED_ACCELERATE });\n        const surfaceOpacityAnimation = surfaceEl.animate([{ opacity: 1 }, { opacity: 0 }], { duration: SURFACE_OPACITY_DURATION, delay: SURFACE_OPACITY_DELAY });\n        const childrenAnimations = [];\n        for (let i = 0; i < children.length; i++) {\n            // If the animation is closing upwards, then reverse the list of\n            // children so that we animate in the opposite direction.\n            const directionalIndex = closingDownwards ? i : children.length - 1 - i;\n            const child = children[directionalIndex];\n            const animation = child.animate([{ opacity: 1 }, { opacity: 0 }], {\n                duration: ITEM_OPACITY_DURATION,\n                delay: ITEM_OPACITY_INITIAL_DELAY + DELAY_BETWEEN_ITEMS * i,\n            });\n            // Make sure the items stay hidden at the end of each child animation.\n            // We clean this up at the end of the overall animation.\n            animation.addEventListener('finish', () => {\n                child.classList.toggle('md-menu-hidden', true);\n            });\n            childrenAnimations.push([child, animation]);\n        }\n        signal.addEventListener('abort', () => {\n            surfaceHeightAnimation.cancel();\n            downPositionCorrectionAnimation.cancel();\n            surfaceOpacityAnimation.cancel();\n            childrenAnimations.forEach(([child, animation]) => {\n                animation.cancel();\n                child.classList.toggle('md-menu-hidden', false);\n            });\n            reject();\n        });\n        surfaceHeightAnimation.addEventListener('finish', () => {\n            surfaceEl.classList.toggle('animating', false);\n            childrenAnimations.forEach(([child]) => {\n                child.classList.toggle('md-menu-hidden', false);\n            });\n            this.openCloseAnimationSignal.finish();\n            this.dispatchEvent(new Event('closed'));\n            resolve(true);\n        });\n        return animationEnded;\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        if (!isServer) {\n            window.addEventListener('click', this.onWindowClick, { capture: true });\n            window.addEventListener('pointerdown', this.onWindowPointerdown);\n            window.addEventListener('pointerup', this.onWindowPointerup);\n        }\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        if (!isServer) {\n            window.removeEventListener('click', this.onWindowClick, { capture: true });\n            window.removeEventListener('pointerdown', this.onWindowPointerdown);\n            window.removeEventListener('pointerup', this.onWindowPointerup);\n        }\n    }\n    onCloseMenu() {\n        this.close();\n    }\n    onDeactivateItems(event) {\n        event.stopPropagation();\n        this.listController.onDeactivateItems();\n    }\n    onRequestActivation(event) {\n        event.stopPropagation();\n        this.listController.onRequestActivation(event);\n    }\n    handleDeactivateTypeahead(event) {\n        // stopPropagation so that this does not deactivate any typeaheads in menus\n        // nested above it e.g. md-sub-menu\n        event.stopPropagation();\n        this.typeaheadActive = false;\n    }\n    handleActivateTypeahead(event) {\n        // stopPropagation so that this does not activate any typeaheads in menus\n        // nested above it e.g. md-sub-menu\n        event.stopPropagation();\n        this.typeaheadActive = true;\n    }\n    handleStayOpenOnFocusout(event) {\n        event.stopPropagation();\n        this.stayOpenOnFocusout = true;\n    }\n    handleCloseOnFocusout(event) {\n        event.stopPropagation();\n        this.stayOpenOnFocusout = false;\n    }\n    close() {\n        this.open = false;\n        const maybeSubmenu = this.slotItems;\n        maybeSubmenu.forEach(item => {\n            item.close?.();\n        });\n    }\n    show() {\n        this.open = true;\n    }\n    /**\n     * Activates the next item in the menu. If at the end of the menu, the first\n     * item will be activated.\n     *\n     * @return The activated menu item or `null` if there are no items.\n     */\n    activateNextItem() {\n        return this.listController.activateNextItem() ?? null;\n    }\n    /**\n     * Activates the previous item in the menu. If at the start of the menu, the\n     * last item will be activated.\n     *\n     * @return The activated menu item or `null` if there are no items.\n     */\n    activatePreviousItem() {\n        return this.listController.activatePreviousItem() ?? null;\n    }\n}\n(() => {\n    // We want to manage tabindex ourselves.\n    setupHostAria(Menu, { focusable: false });\n})();\n__decorate([\n    query('.menu')\n], Menu.prototype, \"surfaceEl\", void 0);\n__decorate([\n    query('slot')\n], Menu.prototype, \"slotEl\", void 0);\n__decorate([\n    property()\n], Menu.prototype, \"anchor\", void 0);\n__decorate([\n    property()\n], Menu.prototype, \"positioning\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Menu.prototype, \"quick\", void 0);\n__decorate([\n    property({ type: Boolean, attribute: 'has-overflow' })\n], Menu.prototype, \"hasOverflow\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Menu.prototype, \"open\", void 0);\n__decorate([\n    property({ type: Number, attribute: 'x-offset' })\n], Menu.prototype, \"xOffset\", void 0);\n__decorate([\n    property({ type: Number, attribute: 'y-offset' })\n], Menu.prototype, \"yOffset\", void 0);\n__decorate([\n    property({ type: Number, attribute: 'typeahead-delay' })\n], Menu.prototype, \"typeaheadDelay\", void 0);\n__decorate([\n    property({ attribute: 'anchor-corner' })\n], Menu.prototype, \"anchorCorner\", void 0);\n__decorate([\n    property({ attribute: 'menu-corner' })\n], Menu.prototype, \"menuCorner\", void 0);\n__decorate([\n    property({ type: Boolean, attribute: 'stay-open-on-outside-click' })\n], Menu.prototype, \"stayOpenOnOutsideClick\", void 0);\n__decorate([\n    property({ type: Boolean, attribute: 'stay-open-on-focusout' })\n], Menu.prototype, \"stayOpenOnFocusout\", void 0);\n__decorate([\n    property({ type: Boolean, attribute: 'skip-restore-focus' })\n], Menu.prototype, \"skipRestoreFocus\", void 0);\n__decorate([\n    property({ attribute: 'default-focus' })\n], Menu.prototype, \"defaultFocus\", void 0);\n__decorate([\n    queryAssignedElements({ flatten: true })\n], Menu.prototype, \"slotItems\", void 0);\n__decorate([\n    state()\n], Menu.prototype, \"typeaheadActive\", void 0);\n//# sourceMappingURL=menu.js.map","/**\n  * @license\n  * Copyright 2022 Google LLC\n  * SPDX-License-Identifier: Apache-2.0\n  */\nimport { css } from 'lit';\nexport const styles = css `:host{--md-elevation-level: var(--md-menu-container-elevation, 2);--md-elevation-shadow-color: var(--md-menu-container-shadow-color, var(--md-sys-color-shadow, #000));min-width:112px;color:unset;display:contents}md-focus-ring{--md-focus-ring-shape: var(--md-menu-container-shape, 4px)}.menu{border-radius:var(--md-menu-container-shape, 4px);display:none;opacity:0;z-index:20;position:absolute;user-select:none;max-height:inherit;height:inherit;min-width:inherit;max-width:inherit}.fixed{position:fixed}.items{display:block;list-style-type:none;margin:0;outline:none;box-sizing:border-box;background-color:var(--md-menu-container-color, var(--md-sys-color-surface-container, #f3edf7));height:inherit;max-height:inherit;overflow:auto;min-width:inherit;max-width:inherit;border-radius:inherit}.item-padding{padding-block:8px}.has-overflow .items{overflow:visible}.animating .items{overflow:hidden}.has-overflow.animating .items{pointer-events:none}.animating ::slotted(.md-menu-hidden){opacity:0}slot{display:block;height:inherit;max-height:inherit}::slotted(:is(md-divider,[role=separator])){margin:8px 0}/*# sourceMappingURL=menu-styles.css.map */\n`;\n//# sourceMappingURL=menu-styles.css.js.map","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport { customElement } from 'lit/decorators.js';\nimport { styles as forcedColors } from './internal/forced-colors-styles.css.js';\nimport { Menu } from './internal/menu.js';\nimport { styles } from './internal/menu-styles.css.js';\nexport { FocusState } from './internal/controllers/shared.js';\nexport { Corner } from './internal/menu.js';\n/**\n * @summary Menus display a list of choices on a temporary surface.\n *\n * @description\n * Menus appear when users interact with a button, action, or other control.\n *\n * They can be opened from a variety of elements, most commonly icon buttons,\n * buttons, and text fields.\n *\n * md-menu listens for the `close-menu` and `deselect-items` events.\n *\n * - `close-menu` closes the menu when dispatched from a child element.\n * - `deselect-items` deselects all of its immediate menu-item children.\n *\n * @example\n * ```html\n * <div style=\"position:relative;\">\n *   <button\n *       id=\"anchor\"\n *       @click=${() => this.menuRef.value.show()}>\n *     Click to open menu\n *   </button>\n *   <!--\n *     `has-overflow` is required when using a submenu which overflows the\n *     menu's contents.\n *\n *     Additionally, `anchor` ingests an idref which do not pass through shadow\n *     roots. You can also set `.anchorElement` to an element reference if\n *     necessary.\n *   -->\n *   <md-menu anchor=\"anchor\" has-overflow ${ref(menuRef)}>\n *     <md-menu-item headline=\"This is a headline\"></md-menu-item>\n *     <md-sub-menu>\n *       <md-menu-item\n *           slot=\"item\"\n *           headline=\"this is a submenu item\">\n *       </md-menu-item>\n *       <md-menu slot=\"menu\">\n *         <md-menu-item headline=\"This is an item inside a submenu\">\n *         </md-menu-item>\n *       </md-menu>\n *     </md-sub-menu>\n *   </md-menu>\n * </div>\n * ```\n *\n * @final\n * @suppress {visibility}\n */\nexport let MdMenu = class MdMenu extends Menu {\n};\nMdMenu.styles = [styles, forcedColors];\nMdMenu = __decorate([\n    customElement('md-menu')\n], MdMenu);\n//# sourceMappingURL=menu.js.map","<template>\n  <span style=\"position: relative\">\n    <IOIconButtonFilled id=\"anchor\"/>\n    <md-menu id=\"option-menu\">\n      <md-menu-item>\n        <div slot=\"headline\">Apple</div>\n      </md-menu-item>\n      <md-menu-item>\n        <div slot=\"headline\">Banana</div>\n      </md-menu-item>\n      <md-menu-item>\n        <div slot=\"headline\">Cucumber</div>\n      </md-menu-item>\n    </md-menu>\n  </span>\n</template>\n\n<script type=\"module\">\nimport IOIconButtonFilled from '@/components/Buttons/IconButtons/IOIconButtonFilled.vue';\n\nexport default {\n  name: 'IOIconMenu',\n  components: {\n    IOIconButtonFilled,\n  },\n};\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const anchorEl = document.getElementById('anchor');\n  const menuEl = document.getElementById('option-menu');\n\n  if(anchorEl && menuEl) {\n    menuEl.anchorElement = anchorEl;\n\n    anchorEl.addEventListener('click', () => {\n      menuEl.open = !menuEl.open;\n    });\n  }\n});\n</script>\n"],"names":["styles","css","activateFirstItem","items","isActivatable","isItemNotDisabled","firstItem","getFirstActivatableItem","activateLastItem","lastItem","getLastActivatableItem","getActiveItem","i","item","getNextItem","index","nextIndex","getPrevItem","prevIndex","activateNextItem","activeItemRecord","next","activatePreviousItem","prev","NavigableKeys","ListController","config","event","key","isRtl","inlinePrevious","inlineNext","target","encounteredActivated","firstActivatableItem","isItem","getPossibleItems","deactivateItem","activateItem","isNavigableKey","maybeItems","itemOrParent","subItem","SelectionKey","KeydownCloseKey","isClosableKey","code","value","isElementInSubtree","container","focusEv","composedPath","listener","ev","FocusState","Corner","SurfacePositionController","host","getProperties","surfaceEl","anchorEl","anchorCornerRaw","surfaceCornerRaw","positioning","xOffset","yOffset","repositionStrategy","anchorCorner","surfaceCorner","surfaceRect","anchorRect","surfaceBlock","surfaceInline","anchorBlock","anchorInline","isLTR","blockInset","blockOutOfBoundsCorrection","surfaceBlockProperty","flippedSurfaceBlock","flippedAnchorBlock","flippedBlock","inlineInset","inlineOutOfBoundsCorrection","surfaceInlineProperty","flippedSurfaceInline","flippedAnchorInline","flippedInline","relativeToWindow","isSurfaceBlockStart","isSurfaceBlockEnd","blockAnchorOffset","blockTopLayerOffset","isLTRBool","isRTL","isSurfaceInlineStart","isSurfaceInlineEnd","inlineAnchorOffset","inlineTopLayerOffsetLTR","inlineTopLayerOffsetRTL","inlineTopLayerOffset","props","hasChanged","openChanged","hasAnchor","hasSurface","TYPEAHEAD_RECORD","TypeaheadController","el","record","lastActiveIndex","numRecords","rebaseIndexOnActive","matchingRecords","a","b","isNewQuery","nextRecord","DEFAULT_TYPEAHEAD_BUFFER_TIME","submenuNavKeys","menuNavKeys","getFocusedElement","activeDoc","activeEl","_a","Menu","LitElement","element","createAnimationSignal","maybeItem","arrowOpen","polyfillElementInternalsAria","oldRestoreFocus","animationAborted","first","last","_b","path","changed","html","classMap","styleMap","slotEl","openDirection","signal","height","openingUpwards","children","FULL_DURATION","SURFACE_OPACITY_DURATION","ITEM_OPACITY_DURATION","DELAY_BETWEEN_ITEMS","surfaceHeightAnimation","EASING","upPositionCorrectionAnimation","surfaceOpacityAnimation","childrenAnimations","directionalIndex","child","animation","resolveAnimation","animationFinished","resolve","reject","animationEnded","res","rej","closingDownwards","SURFACE_OPACITY_DELAY","ITEM_OPACITY_INITIAL_DELAY","END_HEIGHT_PERCENTAGE","downPositionCorrectionAnimation","setupHostAria","__decorate","query","property","queryAssignedElements","state","MdMenu","forcedColors","customElement","_sfc_main","IOIconButtonFilled","menuEl","_hoisted_1","_hoisted_2","_createElementVNode","_hoisted_3","_hoisted_4","_openBlock","_createElementBlock","_createVNode","_component_IOIconButtonFilled","_component_md_menu","_component_md_menu_item"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}